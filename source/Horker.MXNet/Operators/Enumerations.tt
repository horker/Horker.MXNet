<#@ template language="C#" debug="True" #>
<#@ output extension="cs" #>
<#
var enums = new EnumDefinition[] {
    new EnumDefinition() {
        TypeName = "LeakyReLUActType",
        Values = new[] { "elu", "gelu", "leaky", "prelu", "rrelu", "selu" },
        DisplayValues = new[] { "ELU", "GeLU", "Leaky", "PReLU", "RReLU", "SeLU" },
        DefaultValue = "\"leaky\""
    },
    new EnumDefinition() {
        TypeName = "ActType",
        Values = new[] { "relu", "sigmoid", "softrelu", "softsign", "tanh" },
        DisplayValues = new[] { "ReLU", "sigmoid", "SoftReLU", "SoftSign", "Tanh" },
        DefaultValue = "\"relu\""
    },
    new EnumDefinition() {
        TypeName = "BlankLabelType",
        Values = new[] { "first", "last" },
        DisplayValues = new[] { "First", "Last" },
        DefaultValue = "\"first\""
    },
    new EnumDefinition() {
        TypeName = "CuDNNTuneType",
        Values = new[] { "fastest", "limited_workspace", "off" },
        DisplayValues = new[] { "Fastest", "LimitedWorkspace", "Off" },
        DefaultValue = "null"
    },
    new EnumDefinition() {
        TypeName = "FormatType",
        Values = new[] { "center", "corner" },
        DisplayValues = new[] { "Center", "Corner" },
        DefaultValue = "\"corner\""
    },
    new EnumDefinition() {
        TypeName = "SType",
        Values = new[] { "csr", "default", "row_sparse" },
        DisplayValues = new[] { "Csr", "Default", "RowSparse" },
        DefaultValue = "null"
    },
    new EnumDefinition() {
        TypeName = "LayoutType",
        Values = new[] { "NCDHW", "NCHW", "NCW", "NDHWC", "NHWC", "NWC" },
        DisplayValues = new[] { "NCDHW", "NCHW", "NCW", "NDHWC", "NHWC", "NWC" },
        DefaultValue = "null"
    },
    new EnumDefinition() {
        TypeName = "MultiInputModeType",
        Values = new[] { "concat", "sum" },
        DisplayValues = new[] { "Concat", "Sum" },
        DefaultValue = "\"Concat\""
    },
    new EnumDefinition() {
        TypeName = "NormalizationType",
        Values = new[] { "batch", "null", "valid" },
        DisplayValues = new[] { "Batch", "Null", "Valid" },
        DefaultValue = "\"null\""
    },
    new EnumDefinition() {
        TypeName = "PoolType",
        Values = new[] { "avg", "lp", "max", "sum" },
        DisplayValues = new[] { "Avg", "Lp", "Max", "Sum" },
        DefaultValue = "\"Max\""
    },
    new EnumDefinition() {
        TypeName = "PoolingConventionType",
        Values = new[] { "full", "same", "valid" },
        DisplayValues = new[] { "Full", "Same", "Valid" },
        DefaultValue = "\"Valid\""
    },
    new EnumDefinition() {
        TypeName = "RetType",
        Values = new[] { "both", "indices", "mask", "value" },
        DisplayValues = new[] { "Both", "Indices", "Mask", "Value" },
        DefaultValue = "\"Indices\""
    },
    new EnumDefinition() {
        TypeName = "SampleType",
        Values = new[] { "bilinear", "nearest" },
        DisplayValues = new[] { "Bilinear", "Nearest" },
        DefaultValue = "null"
    },
    new EnumDefinition() {
        TypeName = "TransformType",
        Values = new[] { "affine", "warp" },
        DisplayValues = new[] { "Affine", "Warp" },
        DefaultValue = "null"
    }
};
#>
using System;

namespace Horker.MXNet.Operators
{
<#
foreach (var e in enums)
{
    var t = e.TypeName;
#>
    public class <#= t #>
    {
        private static readonly string[] _values = new[] {
            "<#= string.Join("\", \"", e.Values) #>"
        };

<#
    for (var i = 0; i < e.DisplayValues.Length; ++i)
    {
#>
        public static <#= t #> <#= e.DisplayValues[i] #> { get; private set; }
<#
    }
#>

        public static <#= t #> DefaultValue { get; private set; }

        private string _value;

        static <#= t #>()
        {
<#
    for (var i = 0; i < e.DisplayValues.Length; ++i)
    {
#>
            <#= e.DisplayValues[i] #> = new <#= t #>() { _value = _values[<#= i #>] };
<#
    }
#>

            DefaultValue = new <#= t #>() { _value = <#= e.DefaultValue #> };
        }

        private <#= t #>()
        {
        }

        public <#= t #>(string s)
        {
            for (var i = 0; i < _values.Length; ++i)
            {
                if (s.Equals(_values[i], StringComparison.OrdinalIgnoreCase))
                {
                    _value = _values[i];
                    return;
                }
            }

            throw new ArgumentException($"Invalid type string: {s}");
        }

        public static implicit operator string(<#= t #> obj)
        {
            return obj._value ?? DefaultValue._value;
        }
    }

<#
    }
#>
}
<#+
class EnumDefinition
{
    public string TypeName;
    public string[] Values;
    public string[] DisplayValues;
    public string DefaultValue;
}
#>
