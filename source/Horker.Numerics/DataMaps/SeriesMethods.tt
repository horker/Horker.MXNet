<#@ template debug="true" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#   
var methodNames = new []
{
	Tuple.Create("CumulativeMax", "", ""),
	Tuple.Create("CumulativeMin", "", ""),
	Tuple.Create("CumulativeProduct", "", ""),
	Tuple.Create("CumulativeSum", "", ""),
	Tuple.Create("FillNaN", "object fillValue", ", fillValue"),
	Tuple.Create("GetUnique", "", ""),
	Tuple.Create("RemoveNaN", "", ""),
};

var nonSeriesMethods = new[]
{
	Tuple.Create("CumulativeMaxFill", "void", "", ""),
	Tuple.Create("CumulativeMinFill", "void", "", ""),
	Tuple.Create("CumulativeProductFill", "void", "", ""),
	Tuple.Create("CumulativeSumFill", "void", "", ""),
	Tuple.Create("CountNaN", "int", "", ""),
	Tuple.Create("CountUnique", "int", "", ""),
	Tuple.Create("Describe", "Summary", "", ""),
	Tuple.Create("FillNaNFill", "void", "object fillValue", ", fillValue"),
	Tuple.Create("SortFill", "void", "", "")
};
#>
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;

namespace Horker.Numerics.DataMaps
{
    public partial class SeriesBase : IList
    {
        enum MethodIndex
        {
<#   
foreach (var t in methodNames) {
#>
			<#= t.Item1 #>,
<#
}
foreach (var t in nonSeriesMethods) {
#>
			<#= t.Item1 #>,
<#
}
#>
        }

<#   
foreach (var t in methodNames) {
#>
        public SeriesBase <#= t.Item1  #>(<#= t.Item2 #>)
        {
			var m = GetMethodInfo(MethodIndex.<#= t.Item1 #>);
            return new Series((IList)m.Invoke(null, new object[] { UnderlyingList<#= t.Item3 #> }));
        }

<#
}
foreach (var t in nonSeriesMethods) {
#>
        public <#= t.Item2 #> <#= t.Item1 #>(<#= t.Item3 #>)
        {
			var m = GetMethodInfo(MethodIndex.<#= t.Item1 #>);

<# if (t.Item2 == "void") { #>
            m.Invoke(null, new object[] { UnderlyingList<#= t.Item4 #> });
<# } else { #>
            return (<#= t.Item2 #>)m.Invoke(null, new object[] { UnderlyingList<#= t.Item4 #> });
<# } #>
        }

<#
}
#>
	}
}
